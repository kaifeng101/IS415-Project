<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.555">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Kai Feng &amp; Edwin">

<title>Vietnam PCI Influence Analysis - User Guide</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Vietnam PCI Influence Analysis</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./about.html"> 
<span class="menu-text">About Us</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./about.html"> 
<span class="menu-text">Project</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./poster.html"> 
<span class="menu-text">Poster</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./user_guide.html" aria-current="page"> 
<span class="menu-text">User Guide</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#user-guide" id="toc-user-guide" class="nav-link active" data-scroll-target="#user-guide">User Guide</a>
  <ul class="collapse">
  <li><a href="#user-guide-for-pci-spatial-pattern-analysis-and-hotspots-analysis" id="toc-user-guide-for-pci-spatial-pattern-analysis-and-hotspots-analysis" class="nav-link" data-scroll-target="#user-guide-for-pci-spatial-pattern-analysis-and-hotspots-analysis">User Guide for PCI Spatial Pattern Analysis and Hotspots Analysis</a></li>
  <li><a href="#user-guide-for-fdi-spatial-pattern-analysis-and-hotspots-analysis" id="toc-user-guide-for-fdi-spatial-pattern-analysis-and-hotspots-analysis" class="nav-link" data-scroll-target="#user-guide-for-fdi-spatial-pattern-analysis-and-hotspots-analysis">User Guide for FDI Spatial Pattern Analysis and Hotspots Analysis</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">User Guide</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Kai Feng &amp; Edwin </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="user-guide" class="level1">
<h1>User Guide</h1>
<section id="user-guide-for-pci-spatial-pattern-analysis-and-hotspots-analysis" class="level2">
<h2 class="anchored" data-anchor-id="user-guide-for-pci-spatial-pattern-analysis-and-hotspots-analysis">User Guide for PCI Spatial Pattern Analysis and Hotspots Analysis</h2>
<section id="local-moran-of-pci" class="level4">
<h4 class="anchored" data-anchor-id="local-moran-of-pci"><strong><em>Local Moran of PCI</em></strong></h4>
<p>This section displays the LISA map, which highlights local clusters and spatial outliers based on Local Moran’s I statistic.</p>
<ol type="1">
<li><p><strong>Mapping Variable (Year)</strong>: Select the PCI year to analyze.</p>
<ul>
<li><p>Options are dynamically populated based on available data</p>
<ul>
<li>Y2012-Y2022</li>
</ul></li>
</ul></li>
<li><p><strong>Contiguity Method</strong>: Choose the spatial contiguity method.</p>
<ul>
<li><p>Options: <code>Queen</code> (default) or <code>Rook</code>.</p></li>
<li><p>“Queen” considers all surrounding areas as neighbors, while “Rook” only considers those sharing borders. Selecting the appropriate method affects which areas are considered spatially related, impacting the detection of clusters or patterns.</p></li>
</ul></li>
<li><p><strong>Spatial Weights Style</strong>: Select a weighting style for spatial association.</p>
<ul>
<li><p>Options: <code>W</code> (Row standardized), <code>B</code> (Binary), <code>C</code> (Globally standardized), <code>U</code> (C / number of neighbors), <code>minmax</code>, <code>S</code> (Variance).</p></li>
<li><p>This setting ensures that neighboring areas are weighted consistently, making the spatial correlation measures more meaningful and comparable across regions.</p></li>
</ul></li>
<li><p><strong>Number of Simulations</strong>: Set the number of simulations for significance testing (between 99 and 499).</p>
<ul>
<li>Users can adjust this based on the desired balance between accuracy and computational time.</li>
</ul></li>
<li><p><strong>Confidence Level</strong>: Select the confidence level for the LISA significance results.</p>
<ul>
<li><p>Options: 95% (0.05) or 99% (0.01).</p></li>
<li><p>A higher confidence level (e.g., 99%) reduces the chance of false positives, ensuring the detected patterns are statistically reliable.</p></li>
</ul></li>
<li><p><strong>LISA Classification</strong>: Select a classification method for the LISA clusters.</p>
<ul>
<li><p>Options: <code>mean</code>, <code>median</code>, <code>pysal</code>.</p></li>
<li><p>This affects the interpretation of clusters (e.g., high-high or low-low areas) and helps customize the analysis to specific policy or research needs.</p></li>
</ul></li>
<li><p><strong>Local Moran’s Statistic</strong>: Choose the type of Local Moran’s statistic to display.</p>
<ul>
<li>Options: <code>local moran(ii)</code>, <code>expectation(eii)</code>, <code>variance(var_ii)</code>, <code>std deviation(z_ii)</code>, <code>P-value</code></li>
</ul></li>
</ol>
<p><img src="images/photo_2024-11-13_21-12-31.jpg" class="img-fluid" width="415"></p>
<p>The Main Panel displays the results based on the selected calibration inputs:</p>
<p><strong>Local Moran of PCI</strong>: The LISA map shows spatial clusters of similar PCI levels and outliers, indicating local dependencies or deviations.</p>
<p><img src="images/clipboard-3822262858.png" class="img-fluid"></p>
</section>
<section id="gi-hotspot-analysis-of-pci" class="level4">
<h4 class="anchored" data-anchor-id="gi-hotspot-analysis-of-pci"><em>Gi Hotspot Analysis of PCI</em>*</h4>
<p>In this section, users can view the Gi* hotspot map, which identifies spatial clusters of high and low PCI values.</p>
<ol type="1">
<li><p><strong>Mapping Variable (Year)</strong>: Select the PCI year to analyze.</p>
<ul>
<li>Options: 2019, 2020, 2021, 2022.</li>
</ul></li>
<li><p><strong>Classification Method</strong>: Choose a method for classifying PCI values on the map.</p>
<ul>
<li><p>Options: <code>cont</code>, <code>equal</code>, <code>pretty</code>, <code>quantile</code>, <code>kmeans</code>, <code>hclust</code>, <code>bclust</code>, <code>fisher</code>, <code>jenks</code>.</p></li>
<li><p>This dropdown lets users choose the classification method for dividing the data into classes or intervals.</p></li>
</ul></li>
<li><p><strong>Number of Classes</strong>: Set the number of classification levels (between 5 and 10) for the PCI values.</p>
<ul>
<li>A slider allows the user to set the number of data classes, which are the ranges into which the data is divided for color-coding on the map</li>
</ul></li>
<li><p><strong>Colour Scheme</strong>: Select a color scheme to visualize PCI hotspots and cold spots.</p>
<ul>
<li><p>Options: Blues, Reds, Greens, Yellow-Orange-Red, Yellow-Orange-Brown, Yellow-Green, Orange-Red.</p></li>
<li><p>Users can choose a color scheme to represent different classes on the map.</p></li>
</ul></li>
<li><p><strong>Level of Transparency</strong>: Adjust the map’s opacity for better visual contrast (range: 0 to 1).</p>
<ul>
<li>This slider controls the transparency of the map layer, with a scale from 0 (fully transparent) to 1 (fully opaque).</li>
</ul></li>
</ol>
<p><img src="images/photo_2024-11-10_20-32-08.jpg" class="img-fluid"></p>
<p>The Main Panel displays the results based on the selected calibration inputs:</p>
<p><strong>Emerging Hotspot Analysis of PCI</strong>: The Gi* hotspot map highlights significant PCI hotspots (high PCI clusters) and cold spots (low PCI clusters) across provinces for the selected year.</p>
<p><img src="images/photo_2024-11-10_20-32-08-01.jpg" class="img-fluid"></p>
</section>
</section>
<section id="user-guide-for-fdi-spatial-pattern-analysis-and-hotspots-analysis" class="level2">
<h2 class="anchored" data-anchor-id="user-guide-for-fdi-spatial-pattern-analysis-and-hotspots-analysis">User Guide for FDI Spatial Pattern Analysis and Hotspots Analysis</h2>
<section id="local-moran-of-fdi" class="level4">
<h4 class="anchored" data-anchor-id="local-moran-of-fdi"><strong><em>Local Moran of FDI</em></strong></h4>
<p>This section displays the LISA map, which highlights local clusters and spatial outliers based on Local Moran’s I statistic.</p>
<ol type="1">
<li><p><strong>Mapping Variable (Year)</strong>: Select the FDI category to analyze.</p>
<ul>
<li><p>Options are dynamically populated based on available data</p>
<ul>
<li><p>T1: Total Projects</p></li>
<li><p>T2: Total Registered Capital</p></li>
</ul></li>
</ul></li>
<li><p><strong>Contiguity Method</strong>: Choose the spatial contiguity method.</p>
<ul>
<li><p>Options: <code>Queen</code> (default) or <code>Rook</code>.</p></li>
<li><p>“Queen” considers all surrounding areas as neighbors, while “Rook” only considers those sharing borders. Selecting the appropriate method affects which areas are considered spatially related, impacting the detection of clusters or patterns.</p></li>
</ul></li>
<li><p><strong>Spatial Weights Style</strong>: Select a weighting style for spatial association.</p>
<ul>
<li><p>Options: <code>W</code> (Row standardized), <code>B</code> (Binary), <code>C</code> (Globally standardized), <code>U</code> (C / number of neighbors), <code>minmax</code>, <code>S</code> (Variance).</p></li>
<li><p>This setting ensures that neighboring areas are weighted consistently, making the spatial correlation measures more meaningful and comparable across regions.</p></li>
</ul></li>
<li><p><strong>Number of Simulations</strong>: Set the number of simulations for significance testing (between 99 and 499).</p>
<ul>
<li>Users can adjust this based on the desired balance between accuracy and computational time.</li>
</ul></li>
<li><p><strong>Confidence Level</strong>: Select the confidence level for the LISA significance results.</p>
<ul>
<li><p>Options: 95% (0.05) or 99% (0.01).</p></li>
<li><p>A higher confidence level (e.g., 99%) reduces the chance of false positives, ensuring the detected patterns are statistically reliable.</p></li>
</ul></li>
<li><p><strong>LISA Classification</strong>: Select a classification method for the LISA clusters.</p>
<ul>
<li><p>Options: <code>mean</code>, <code>median</code>, <code>pysal</code>.</p></li>
<li><p>This affects the interpretation of clusters (e.g., high-high or low-low areas) and helps customize the analysis to specific policy or research needs.</p></li>
</ul></li>
<li><p><strong>Local Moran’s Statistic</strong>: Choose the type of Local Moran’s statistic to display.</p>
<ul>
<li>Options: <code>local moran(ii)</code>, <code>expectation(eii)</code>, <code>variance(var_ii)</code>, <code>std deviation(z_ii)</code>, <code>P-value</code></li>
</ul></li>
</ol>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/photo_2024-11-10_20-32-05-01.jpg" class="img-fluid figure-img"></p>
<figcaption>The Main Panel displays the results based on the selected calibration inputs:</figcaption>
</figure>
</div>
<p><strong>Local Moran of FDI</strong>: The LISA map shows spatial clusters of similar total projects and total registered capitals levels and outliers, indicating local dependencies or deviations.</p>
</section>
<section id="gi-hotspot-analysis-of-pci-1" class="level4">
<h4 class="anchored" data-anchor-id="gi-hotspot-analysis-of-pci-1"><em>Gi Hotspot Analysis of PCI</em>*</h4>
<p>In this section, users can view the Gi* hotspot map, which identifies spatial clusters of high and low PCI values.</p>
<ol type="1">
<li><p><strong>Mapping Variable (Year)</strong>: Select the FDI category to analyze.</p>
<ul>
<li>Options: Total Projects and Total registered capital</li>
</ul></li>
<li><p><strong>Classification Method</strong>: Choose a method for classifying PCI values on the map.</p>
<ul>
<li><p>Options: <code>cont</code>, <code>equal</code>, <code>pretty</code>, <code>quantile</code>, <code>kmeans</code>, <code>hclust</code>, <code>bclust</code>, <code>fisher</code>, <code>jenks</code>.</p></li>
<li><p>This dropdown lets users choose the classification method for dividing the data into classes or intervals.</p></li>
</ul></li>
<li><p><strong>Number of Classes</strong>: Set the number of classification levels (between 5 and 10) for the PCI values.</p>
<ul>
<li>A slider allows the user to set the number of data classes, which are the ranges into which the data is divided for color-coding on the map</li>
</ul></li>
<li><p><strong>Colour Scheme</strong>: Select a color scheme to visualize PCI hotspots and cold spots.</p>
<ul>
<li><p>Options: Blues, Reds, Greens, Yellow-Orange-Red, Yellow-Orange-Brown, Yellow-Green, Orange-Red.</p></li>
<li><p>Users can choose a color scheme to represent different classes on the map.</p></li>
</ul></li>
<li><p><strong>Level of Transparency</strong>: Adjust the map’s opacity for better visual contrast (range: 0 to 1).</p>
<ul>
<li>This slider controls the transparency of the map layer, with a scale from 0 (fully transparent) to 1 (fully opaque).</li>
</ul></li>
</ol>
<p><img src="images/photo_2024-11-10_20-32-10.jpg" class="img-fluid"></p>
<p>The Main Panel displays the results based on the selected calibration inputs:</p>
<p><strong>Emerging Hotspot Analysis of PCI</strong>: The Gi* hotspot map highlights significant FDI category hotspots (high PCI clusters) and cold spots (low PCI clusters) across provinces for the selected year.</p>
<p><img src="images/clipboard-4031888003.png" class="img-fluid"></p>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>